 <!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>River Pts → RIVER 전환 트래커</title>
  <style>
    :root{
      --bd:#e5e7eb; --muted:#6b7280; --bg:#f8fafc; --card:#ffffff; --txt:#111827;
      --good:#16a34a; --warn:#f59e0b; --bad:#ef4444;
    }
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; margin:0; padding:18px; background:var(--bg); color:var(--txt);}
    .wrap{max-width:980px; margin:0 auto;}
    .titlebar{display:flex; gap:12px; align-items:flex-end; justify-content:space-between; flex-wrap:wrap; margin-bottom:12px}
    h1{margin:0; font-size:20px; letter-spacing:-0.2px}
    .subtitle{margin:6px 0 0; color:#4b5563; font-size:13px; line-height:1.35}
    .card{background:var(--card); border:1px solid var(--bd); border-radius:16px; padding:14px; box-shadow:0 1px 0 rgba(0,0,0,.02); margin:12px 0;}
    .row{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
    label{font-size:11px; color:#374151; display:block; margin-bottom:6px}
    select,input,button{font-size:14px; padding:10px 12px; border:1px solid var(--bd); border-radius:12px; background:#fff}
    input{min-width:220px}
    button{cursor:pointer; font-weight:700}
    button.primary{background:#111827; color:#fff; border-color:#111827}
    .btns{display:flex; gap:8px; flex-wrap:wrap}
    .chip{
      border:1px solid var(--bd); background:#fff; padding:8px 10px; border-radius:999px;
      font-size:12px; color:#111827; cursor:pointer; user-select:none;
    }
    .chip.active{border-color:#111827; box-shadow:0 0 0 2px rgba(17,24,39,.08)}
    .hint{font-size:12px; color:var(--muted)}
    .error{color:#b91c1c; font-weight:700; white-space:pre-wrap; margin-top:10px; display:none}

    /* Status (상대 신호등) */
    .statusline{
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px; flex-wrap:wrap;
      padding:12px; border:1px dashed var(--bd); border-radius:14px; background:#fff;
    }
    .badge{
      display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px;
      border:1px solid var(--bd); font-size:12px; font-weight:900;
    }
    .dot{width:10px; height:10px; border-radius:999px; background:#9ca3af}
    .badge.good .dot{background:var(--good)}
    .badge.warn .dot{background:var(--warn)}
    .badge.bad  .dot{background:var(--bad)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}

    /* KPI */
    .kpis{display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:10px; margin-top:12px}
    .kpi{
      border:1px solid var(--bd); border-radius:14px; padding:12px; background:#fff;
      display:flex; flex-direction:column; gap:6px;
    }
    .k{font-size:11px; color:var(--muted)}
    .v{font-size:20px; font-weight:900; letter-spacing:-0.2px}
    .small{font-size:12px; color:var(--muted); line-height:1.35}

    /* GAP KPI: 테두리 색 + 큰 숫자 */
    .kpi-gap { border-width:2px; }
    .kpi-gap.good { border-color: var(--good); }
    .kpi-gap.warn { border-color: var(--warn); }
    .kpi-gap.bad  { border-color: var(--bad); }
    .kpi-gap .v { font-size:28px; }

    /* 설명 콜아웃(명확한 UI 문구) */
    .callout{
      margin-top:8px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--bd);
      background:#fafafa;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:flex-start;
    }
    .callout .tag{
      font-size:11px;
      font-weight:900;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--bd);
      background:#fff;
      white-space:nowrap;
    }
    .callout.good { border-color: rgba(22,163,74,.35); background: rgba(22,163,74,.06); }
    .callout.warn { border-color: rgba(245,158,11,.35); background: rgba(245,158,11,.06); }
    .callout.bad  { border-color: rgba(239,68,68,.35); background: rgba(239,68,68,.06); }
    .callout.good .tag{ border-color: rgba(22,163,74,.45); }
    .callout.warn .tag{ border-color: rgba(245,158,11,.45); }
    .callout.bad  .tag{ border-color: rgba(239,68,68,.45); }
    .callout .msg{font-size:12px; color:#374151; line-height:1.45}

    details{border:1px solid var(--bd); border-radius:14px; background:#fff; padding:10px 12px}
    summary{cursor:pointer; font-weight:900; font-size:13px}
    table{width:100%; border-collapse:collapse; font-size:13px; margin-top:10px}
    th,td{border-bottom:1px solid #eee; padding:8px; text-align:right; vertical-align:top}
    th:first-child, td:first-child{text-align:left}

    @media (max-width:720px){
      .kpis{grid-template-columns:1fr}
      input{min-width:0; width:100%}
      .row{align-items:stretch}
      .btns button{width:100%}
    }
  </style>
</head>

<body>
<div class="wrap">
  <div class="titlebar">
    <div>
      <h1>River Pts → RIVER 전환 트래커</h1>
      <div class="subtitle">
        위: 기대 대비 갭(절대) · 아래: 최근 7일 대비 신호등(상대) + 회복속도(6h) + ETA
      </div>
    </div>
  </div>

  <!-- Controls -->
  <div class="card">
    <div class="row" style="justify-content:space-between;">
      <div>
        <label>기간 프리셋</label>
        <div class="hint">표시 기준: 4h · 분석 기준: 1h (회복속도/ETA)</div>

        <div class="btns" id="presetBtns" style="margin-top:8px">
          <div class="chip" data-preset="1d">1d</div>
          <div class="chip" data-preset="3d">3d</div>
          <div class="chip active" data-preset="7d">7d</div>
          <div class="chip" data-preset="30d">30d</div>
          <div class="chip" data-preset="all">all</div>
        </div>
        <div class="hint" style="margin-top:8px">프리셋 선택 → start/end 자동 설정</div>
      </div>

      <div class="btns">
        <button id="btn" class="primary">불러오기</button>
      </div>
    </div>

    <details style="margin-top:12px">
      <summary>고급 설정: start/end 직접 지정</summary>
      <div class="row" style="margin-top:10px">
        <div>
          <label>start (로컬)</label>
          <input id="start" type="datetime-local" />
        </div>
        <div>
          <label>end (로컬)</label>
          <input id="end" type="datetime-local" />
        </div>
      </div>
    </details>

    <div id="err" class="error"></div>
  </div>

  <!-- KPIs (위에 GAP 먼저) -->
  <div class="card">
    <div class="kpis">
      <!-- GAP: 기대 대비(절대) -->
      <div class="kpi kpi-gap" id="gapCard" style="grid-column:1 / -1;">
        <div class="k">기대 대비 갭(절대): actualRate / expectedRate</div>
        <div class="v" id="gapValue">-</div>
        <div class="small" id="gapDetail">-</div>
        <div class="callout" id="gapCallout">
          <div class="tag">해석(절대)</div>
          <div class="msg" id="gapMsg">-</div>
        </div>
        <div class="small" style="margin-top:6px">
          갭 단계: 초 ≥ -10% · 노 -30% ~ -10% · 빨 &lt; -30%
        </div>
      </div>

      <!-- 상대 신호등 -->
      <div class="kpi" style="grid-column:1 / -1;">
        <div class="statusline">
          <div>
            <div class="badge" id="trafficBadge">
              <span class="dot"></span>
              <span id="trafficText">-</span>
            </div>
            <div class="small" style="margin-top:8px">
              신호등(최근 7일 상대): GREEN ≥ 85% · YELLOW 70~85% · RED &lt; 70%
              (최신 전환율 / 최근 7일 기준 전환율)
            </div>

            <div class="callout" id="relCallout" style="margin-top:10px;">
              <div class="tag">해석(상대)</div>
              <div class="msg" id="relMsg">-</div>
            </div>
          </div>

          <div class="hint">
            <div class="mono" id="statusText">-</div>
          </div>
        </div>
      </div>

      <div class="kpi">
        <div class="k">R_now (최신 전환율)</div>
        <div class="v" id="kpiRnow">-</div>
        <div class="small" id="kpiRnow2">-</div>
      </div>

      <div class="kpi">
        <div class="k">회복속도 slope(6h)</div>
        <div class="v" id="kpiSlope">-</div>
        <div class="small" id="kpiSlope2">-</div>
      </div>

      <div class="kpi">
        <div class="k">ETA</div>
        <div class="v" id="kpiEta">-</div>
        <div class="small" id="kpiEta2">-</div>
      </div>

      <div class="kpi">
        <div class="k">기간 누적 Pts / Tokens</div>
        <div class="v" id="kpiCum">-</div>
        <div class="small" id="kpiCum2">-</div>
      </div>
    </div>
  </div>

  <!-- Details: table only -->
  <details class="card">
    <summary>상세 데이터 보기 (테이블)</summary>
    <div style="overflow:auto; margin-top:10px">
      <table>
        <thead>
          <tr>
            <th>timestamp(UTC)</th>
            <th>ptsAmount</th>
            <th>tokensAmount</th>
            <th>actualRate</th>
            <th>expectedRate</th>
            <th>tokens/pts</th>
          </tr>
        </thead>
        <tbody id="tbody">
          <tr><td colspan="6" style="text-align:left; color:#6b7280;">-</td></tr>
        </tbody>
      </table>
    </div>
  </details>
</div>

<script>
  // Worker / API
  const WORKER_BASE = "https://rapid-violet-e93d.robotjh.workers.dev";
  const API_PATH = "/s2/pts-conversion-chart";

  // 고정 규칙
  const DISPLAY_INTERVAL = "4h";  // 최신 전환율 + 테이블 + actual/expected
  const ANALYSIS_INTERVAL = "1h"; // 회복속도 + ETA
  const SLOPE_LOOKBACK_HOURS = 6;

  // 상대 신호등 기준(최근 7일 대비)
  const GREEN_RATIO = 0.85;
  const RED_RATIO   = 0.70;
  const BASE_RATIO  = 1.00;

  // 기대 대비 갭(절대) 기준: gap% = (actual/expected - 1) * 100
  // 초 >= -10, 노 [-30, -10), 빨 < -30
  const GAP_GREEN_MIN = -10;
  const GAP_YELLOW_MIN = -30;

  const $ = (id) => document.getElementById(id);

  // ---------- formatting ----------
  function fmtNum(x, digits=2) {
    if (!Number.isFinite(x)) return "-";
    return x.toLocaleString(undefined, { maximumFractionDigits: digits });
  }
  function fmtRate(x) {
    if (!Number.isFinite(x)) return "-";
    return x.toLocaleString(undefined, { minimumFractionDigits: 6, maximumFractionDigits: 8 });
  }
  function toLocalInputValue(d) {
    const pad = (n) => String(n).padStart(2,"0");
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
  }
  function parseLocalInputToMs(v) {
    const d = new Date(v);
    const ms = d.getTime();
    return Number.isFinite(ms) ? ms : null;
  }
  function parseTsMs(ts) {
    const ms = Date.parse(ts);
    return Number.isFinite(ms) ? ms : null;
  }
  function humanizeHours(hours) {
    if (!Number.isFinite(hours)) return "-";
    if (hours <= 0) return "0h";
    const d = Math.floor(hours / 24);
    const h = Math.round(hours % 24);
    if (d <= 0) return `${Math.round(hours)}h`;
    return `${d}d ${h}h`;
  }

  // ---------- error / loading ----------
  function showError(msg) {
    const el = $("err");
    el.style.display = "block";
    el.textContent = msg;
  }
  function clearError() {
    const el = $("err");
    el.style.display = "none";
    el.textContent = "";
  }
  function setLoading(isLoading) {
    const btn = $("btn");
    btn.disabled = isLoading;
    btn.textContent = isLoading ? "불러오는 중..." : "불러오기";
  }

  // ---------- api ----------
  function buildWorkerUrl({ interval, startMs, endMs }) {
    const u = new URL(WORKER_BASE + API_PATH);
    u.searchParams.set("interval", interval);
    u.searchParams.set("startTime", String(startMs));
    u.searchParams.set("endTime", String(endMs));
    return u.toString();
  }

  async function fetchRows(interval, startMs, endMs) {
    const url = buildWorkerUrl({ interval, startMs, endMs });
    const res = await fetch(url, {
      method:"GET",
      headers:{ "accept":"application/json" },
      cache:"no-store"
    });
    if (!res.ok) {
      const txt = await res.text().catch(()=>"");
      throw new Error(`HTTP ${res.status}\n${txt}`);
    }
    const payload = await res.json();
    return payload?.data ?? [];
  }

  // ---------- stats ----------
  function safeRateFromRow(r) {
    // tokens/pts 기반
    const p = Number(r?.ptsAmount);
    const t = Number(r?.tokensAmount);
    if (Number.isFinite(p) && p > 0 && Number.isFinite(t)) return t / p;
    // fallback actualRate
    const ar = Number(r?.actualRate);
    return Number.isFinite(ar) ? ar : NaN;
  }

  function safeActualRate(r){
    const ar = Number(r?.actualRate);
    return Number.isFinite(ar) ? ar : safeRateFromRow(r);
  }

  function safeExpectedRate(r){
    const er = Number(r?.expectedRate);
    return Number.isFinite(er) ? er : NaN;
  }

  function median(arr) {
    const a = arr.filter(Number.isFinite).slice().sort((x,y)=>x-y);
    if (!a.length) return NaN;
    const mid = Math.floor(a.length / 2);
    return (a.length % 2) ? a[mid] : (a[mid-1] + a[mid]) / 2;
  }

  // 상대 신호등 (rNow / rBase)
  function labelTrafficLight(rNow, rBase) {
    if (!Number.isFinite(rNow) || !Number.isFinite(rBase) || rBase <= 0) return "-";
    const ratio = rNow / rBase;
    if (ratio >= GREEN_RATIO) return "GREEN";
    if (ratio >= RED_RATIO) return "YELLOW";
    return "RED";
  }

  // 기대 대비 갭 단계 (actual/expected)
  function gapPctFromRates(actual, expected){
    if (!Number.isFinite(actual) || !Number.isFinite(expected) || expected <= 0) return NaN;
    return (actual / expected - 1) * 100;
  }
  function labelGapLight(gapPct){
    if (!Number.isFinite(gapPct)) return "-";
    if (gapPct >= GAP_GREEN_MIN) return "초";
    if (gapPct >= GAP_YELLOW_MIN) return "노";
    return "빨";
  }

  function recoverySlopePerHour(rows, lookbackHours = 6) {
    if (!rows?.length) return NaN;

    let lastIdx = -1;
    for (let i = rows.length - 1; i >= 0; i--) {
      const r = safeRateFromRow(rows[i]);
      if (Number.isFinite(r)) { lastIdx = i; break; }
    }
    if (lastIdx < 0) return NaN;

    const lastMs = parseTsMs(rows[lastIdx].timestamp);
    const rNow = safeRateFromRow(rows[lastIdx]);
    if (!lastMs || !Number.isFinite(rNow)) return NaN;

    const targetMs = lastMs - lookbackHours * 3600 * 1000;

    let prevIdx = -1;
    for (let i = lastIdx; i >= 0; i--) {
      const ms = parseTsMs(rows[i].timestamp);
      if (!ms) continue;
      if (ms <= targetMs) {
        const r = safeRateFromRow(rows[i]);
        if (Number.isFinite(r)) { prevIdx = i; break; }
      }
    }
    if (prevIdx < 0) {
      for (let i = lastIdx - 1; i >= 0; i--) {
        const r = safeRateFromRow(rows[i]);
        if (Number.isFinite(r)) { prevIdx = i; break; }
      }
    }
    if (prevIdx < 0) return NaN;

    const prevMs = parseTsMs(rows[prevIdx].timestamp);
    const rPrev = safeRateFromRow(rows[prevIdx]);
    if (!prevMs || !Number.isFinite(rPrev)) return NaN;

    const dtHours = (lastMs - prevMs) / (3600 * 1000);
    if (!(dtHours > 0)) return NaN;

    return (rNow - rPrev) / dtHours;
  }

  async function fetchRBase7dMedian() {
    const now = Date.now();
    const endMs = now;
    const startMs = endMs - 7 * 24 * 60 * 60 * 1000;
    const rows = await fetchRows(DISPLAY_INTERVAL, startMs, endMs);
    const rates = rows.map(safeRateFromRow).filter(Number.isFinite);
    return median(rates);
  }

  function renderTable(rows) {
    const tb = $("tbody");
    if (!rows || rows.length === 0) {
      tb.innerHTML = `<tr><td colspan="6" style="text-align:left; color:#6b7280;">데이터 없음</td></tr>`;
      return;
    }
    tb.innerHTML = rows.map(r => {
      const p = Number(r.ptsAmount);
      const t = Number(r.tokensAmount);
      const tp = (Number.isFinite(p) && p > 0 && Number.isFinite(t)) ? (t / p) : NaN;
      return `
        <tr>
          <td>${r.timestamp ?? ""}</td>
          <td>${fmtNum(p, 2)}</td>
          <td>${fmtNum(t, 6)}</td>
          <td>${fmtRate(Number(r.actualRate))}</td>
          <td>${fmtRate(Number(r.expectedRate))}</td>
          <td>${fmtRate(tp)}</td>
        </tr>
      `;
    }).join("");
  }

  // ---------- presets ----------
  function setPreset(preset) {
    const now = new Date();
    const end = new Date(now);
    let start;

    if (preset === "1d") start = new Date(end.getTime() - 1*24*60*60*1000);
    if (preset === "3d") start = new Date(end.getTime() - 3*24*60*60*1000);
    if (preset === "7d") start = new Date(end.getTime() - 7*24*60*60*1000);
    if (preset === "30d") start = new Date(end.getTime() - 30*24*60*60*1000);
    if (preset === "all") start = new Date(end.getTime() - 180*24*60*60*1000);

    $("start").value = toLocalInputValue(start);
    $("end").value = toLocalInputValue(end);

    document.querySelectorAll(".chip").forEach(c => c.classList.toggle("active", c.dataset.preset === preset));
  }

  // ---------- badges / callouts ----------
  function setTrafficBadge(light) {
    const badge = $("trafficBadge");
    badge.classList.remove("good","warn","bad");
    if (light === "GREEN") badge.classList.add("good");
    else if (light === "YELLOW") badge.classList.add("warn");
    else if (light === "RED") badge.classList.add("bad");
    $("trafficText").textContent = light;
  }

  function setCallout(el, mode){ // mode: good|warn|bad
    el.classList.remove("good","warn","bad");
    if (mode) el.classList.add(mode);
  }

  function slopeText(s) {
    if (!Number.isFinite(s)) return "-";
    return `${s >= 0 ? "+" : ""}${fmtRate(s)} / hr`;
  }

  async function load() {
    clearError();
    setLoading(true);

    try {
      let startMs = parseLocalInputToMs($("start").value);
      let endMs = parseLocalInputToMs($("end").value);

      const now = Date.now();
      if (!endMs) endMs = now;
      if (!startMs) startMs = endMs - 7 * 24 * 60 * 60 * 1000;

      if (startMs >= endMs) throw new Error("start가 end보다 같거나 이후입니다.");

      // 1) 표시용(4h)
      const rowsDisplay = await fetchRows(DISPLAY_INTERVAL, startMs, endMs);
      renderTable(rowsDisplay);

      // 최신 행
      const last = rowsDisplay.length ? rowsDisplay[rowsDisplay.length - 1] : null;
      if (!last) throw new Error("표시 데이터(4h)가 없습니다.");

      // 2) 기준선(최근 7일 중앙값 @4h)
      const rBase = await fetchRBase7dMedian();

      // 3) 분석용(1h)
      const rowsAnalysis = await fetchRows(ANALYSIS_INTERVAL, startMs, endMs);

      // 누적 (표시 4h)
      let sumPts = 0, sumTok = 0;
      for (const r of rowsDisplay) {
        const p = Number(r.ptsAmount);
        const t = Number(r.tokensAmount);
        if (Number.isFinite(p)) sumPts += p;
        if (Number.isFinite(t)) sumTok += t;
      }

      // R_now (표시 4h 최신) + 기대/실제(절대)
      const rNow = safeRateFromRow(last);
      const actualNow = safeActualRate(last);
      const expectedNow = safeExpectedRate(last);

      // ---- (A) GAP(절대) 카드: 테두리색 + 문구 ----
      const gapPct = gapPctFromRates(actualNow, expectedNow);
      const gapLight = labelGapLight(gapPct);

      // 카드 테두리 클래스
      const gapCard = $("gapCard");
      gapCard.classList.remove("good","warn","bad");
      if (gapLight === "초") gapCard.classList.add("good");
      else if (gapLight === "노") gapCard.classList.add("warn");
      else if (gapLight === "빨") gapCard.classList.add("bad");

      // 콜아웃 배경
      const gapCallout = $("gapCallout");
      setCallout(gapCallout,
        gapLight === "초" ? "good" : gapLight === "노" ? "warn" : gapLight === "빨" ? "bad" : null
      );

      // 값 표시
      $("gapValue").textContent = Number.isFinite(gapPct) ? `${gapPct.toFixed(1)}%` : "-";
      $("gapDetail").textContent =
        `last=${last.timestamp} · actual=${fmtRate(actualNow)} · expected=${fmtRate(expectedNow)}`;

      // 해석 문구(요청한 메시지)
      let gapMsg = "-";
      if (gapLight === "빨") gapMsg = "지금 전환율은 설계 기대 대비 크게 어긋나 있다.";
      else if (gapLight === "노") gapMsg = "지금 전환율은 설계 기대 대비 다소 낮다(경계 구간).";
      else if (gapLight === "초") gapMsg = "지금 전환율은 설계 기대와 크게 어긋나지 않는다.";
      $("gapMsg").textContent = gapMsg;

      // ---- (B) 상대 신호등(최근 7일 대비) + 문구 ----
      const light = labelTrafficLight(rNow, rBase);
      setTrafficBadge(light);

      const ratio = (Number.isFinite(rNow) && Number.isFinite(rBase) && rBase > 0) ? (rNow / rBase) : NaN;
      const ratioText = Number.isFinite(ratio) ? (ratio * 100).toFixed(1) + "%" : "-";

      // 상대 콜아웃 배경
      const relCallout = $("relCallout");
      setCallout(relCallout,
        light === "GREEN" ? "good" : light === "YELLOW" ? "warn" : light === "RED" ? "bad" : null
      );

      let relMsg = "-";
      if (light === "GREEN") relMsg = "그래도 최근 7일 흐름 안에서는 상대적으로 나쁘지 않다.";
      else if (light === "YELLOW") relMsg = "최근 7일 대비 애매한 구간이다. 조금 더 지켜볼 만하다.";
      else if (light === "RED") relMsg = "최근 7일 대비 많이 눌린 상태다. 무리한 진입은 경계.";
      $("relMsg").textContent = relMsg;

      // slope (분석 1h)
      const slope = recoverySlopePerHour(rowsAnalysis, SLOPE_LOOKBACK_HOURS);

      // ETA targets (상대 신호등과 일치)
      const tGreen = Number.isFinite(rBase) ? (GREEN_RATIO * rBase) : NaN; // 85%
      const tRed   = Number.isFinite(rBase) ? (RED_RATIO   * rBase) : NaN; // 70%
      const tBase  = Number.isFinite(rBase) ? (BASE_RATIO  * rBase) : NaN; // 100%

      // KPI: 최신 전환율
      $("kpiRnow").textContent = fmtRate(rNow);
      $("kpiRnow2").textContent = last?.timestamp
        ? `last=${last.timestamp} · 기준(최근7d median)=${fmtRate(rBase)} · ratio=${ratioText}`
        : "-";

      // KPI: 회복속도
      $("kpiSlope").textContent = slopeText(slope);
      $("kpiSlope2").textContent = `lookback=${SLOPE_LOOKBACK_HOURS}h`;

      // KPI: ETA (상대 목표로 통일)
      if (!Number.isFinite(slope) || slope === 0 || !Number.isFinite(rNow) || !Number.isFinite(rBase)) {
        $("kpiEta").textContent = "-";
        $("kpiEta2").textContent = "ETA 계산 불가 (데이터/기울기 부족)";
      } else if (slope > 0) {
        // 회복: GREEN(85%) / BASE(100%)
        let etaGreen = (tGreen - rNow) / slope;
        let etaBase  = (tBase  - rNow) / slope;
        if (Number.isFinite(etaGreen) && etaGreen < 0) etaGreen = 0;
        if (Number.isFinite(etaBase)  && etaBase  < 0) etaBase  = 0;

        $("kpiEta").textContent = `${humanizeHours(etaGreen)} / ${humanizeHours(etaBase)}`;
        $("kpiEta2").textContent = "회복 ETA: GREEN(85%) / BASE(100%) (선형 추정)";
      } else {
        // 악화: RED(70%) 도달 예상
        let etaRed = (tRed - rNow) / slope;
        if (Number.isFinite(etaRed) && etaRed < 0) etaRed = NaN;

        $("kpiEta").textContent = humanizeHours(etaRed);
        $("kpiEta2").textContent = "악화 ETA: RED(70%) 진입 예상 (선형 추정)";
      }

      // KPI: 누적
      $("kpiCum").textContent = `${fmtNum(sumPts,2)} / ${fmtNum(sumTok,6)}`;
      $("kpiCum2").textContent = "Pts / Tokens (선택 기간 합)";

      $("statusText").textContent =
        `절대갭=${Number.isFinite(gapPct)?gapPct.toFixed(1)+"%":"-"}(${gapLight}) · 상대=${light} (ratio=${ratioText}) · slope=${slopeText(slope)}`;

    } catch (e) {
      showError(String(e?.message || e));
    } finally {
      setLoading(false);
    }
  }

  // init
  (function init(){
    setPreset("7d");

    $("presetBtns").addEventListener("click", (ev) => {
      const t = ev.target;
      if (t && t.classList.contains("chip")) setPreset(t.dataset.preset);
    });

    $("btn").addEventListener("click", load);

    // auto load
    load();
  })();
</script>
</body>
</html>
```0
